# 2022.01.03

## Silver I

## # 2667 단지 번호 붙이기

링크 : https://www.acmicpc.net/problem/2667



풀이 **(DFS)**

```python
# n의 개수, graph, visited 정의
n = int(input())
graph = [[0]*n for _ in range(n)]
visited = [[False]*n for _ in range(n)]

# 입력값 graph에 기입
for i in range(n):
    line = input()
    for j, b in enumerate(line):
        graph[i][j] = int(b)
        
# 상하좌우 이동 설정 
dx = [0, 0, -1, 1]
dy = [1, -1, 0, 0]

# dfs 정의
def dfs(x, y):
    global cnt    # 함수 작성 후 추가 
    visited[x][y] = True
    if graph[x][y] == 1:
        cnt += 1
    for i in range(4):
        nx = x + dx[i]
        ny = y + dy[i]
        if 0 <= nx < n and 0 <= ny < n:
            if visited[nx][ny] == False and graph[nx][ny] == 1:
                dfs(nx, ny)

cnt = 0
numlist = []

# 준비된 dfs를 가지고 graph를 탐색
for x in range(n):
    for y in range(n):
        if graph[x][y] == 1 and visited[x][y] == False:
            dfs(x, y)
            numlist.append(cnt)  # cnt된 묶음을 numlist에 입력 
            cnt = 0  # cnt를 초기화해서 다음 계산에 영향을 주지 않도록

# 문제 답 도출
print(len(numlist))
for n in sorted(numlist):
    print(n)
```



* DFS가 아닌 BFS로도 풀 수 있다고 한다

* 2차원 배열 상태에서 탐색 과정을 갖는 문제는 대부분 비슷한 풀이를 갖는 듯 하다

  